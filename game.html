<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR æ‰‹åŠ¿å°„å‡»æ¸¸æˆ beta1.0</title>
    <style>
        /* (æ ·å¼éƒ¨åˆ†ä¸å˜ï¼Œä¿æŒåŸæ ·) */
        body { margin: 0; overflow: hidden; background-color: #000; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); color: #fff; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; font-family: sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite;
            margin-top: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hit-effect {
            position: absolute; color: #ff0; font-weight: bold; font-size: 24px;
            pointer-events: none; opacity: 1; transform: translate(-50%, -50%);
            animation: float-up 0.8s ease-out forwards; z-index: 50;
        }
        @keyframes float-up {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100px) scale(0.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <h1>ğŸ”« æ­£åœ¨åŠ è½½ AR å°„å‡»èµ„æº...</h1>
        <p>è¯·ç¡®ä¿æ‘„åƒå¤´å¯ç”¨ï¼Œæ­£åœ¨ä¸‹è½½ Three.js å’Œ MediaPipe æ¨¡å‹ã€‚</p>
        <div class="loader"></div>
    </div>

    <div id="game-container">
        <video id="webcam" autoplay playsinline style="display: none;"></video>
    </div>

    <script type="module">
        // --- 1. å¯¼å…¥ Three.js å’Œ MediaPipe ---
        
        // **Three.js ä¼˜åŒ–: æ”¹ç”¨ Cloudflare CDN (é€šå¸¸æ›´å¿«)**
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.module.min.js';
        
        // **MediaPipe ä¼˜åŒ–: ä¿æŒç‰ˆæœ¬é”å®šï¼Œä½†æ”¹ç”¨ jsdelivr å®˜æ–¹å‘å¸ƒé“¾æ¥**
        // æ³¨æ„ï¼šè¿™æ˜¯ Three.js èµ„æºï¼Œä¸æ˜¯ hands.js çš„æ¨¡å‹æ–‡ä»¶ï¼Œæ¨¡å‹æ–‡ä»¶è·¯å¾„åœ¨ä¸‹æ–¹ `locateFile` ä¸­è®¾ç½®ã€‚
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js';
        
        // --- 2. å¸¸é‡ä¸æ¸¸æˆé…ç½® (ä¿æŒä¸å˜) ---
        
        const MAX_ENEMIES = 4;
        const ENEMY_RADIUS = 0.5;
        const AIM_ASSIST_DISTANCE = 3; 
        const BULLET_COOLDOWN_MS = 300; 
        const ENEMY_SPEED = 0.005;
        const FRAME_RATE = 60;
        
        // --- 3. æ¸¸æˆçŠ¶æ€ä¸æ ¸å¿ƒå¯¹è±¡ (ä¿æŒä¸å˜) ---

        let videoElement, loadingOverlay;
        let scene, camera, renderer, clock;
        let hands, lastDetectionTime = 0;
        let enemies = [];
        let lastShotTime = 0;
        let isShooting = false;
        let isReadyToShoot = true; 
        let isGameStarted = false;

        const crosshairGeometry = new THREE.SphereGeometry(0.05);
        const crosshairMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const crosshair = new THREE.Mesh(crosshairGeometry, crosshairMaterial);
        
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -10)]);
        const laserMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const laserLine = new THREE.Line(laserGeometry, laserMaterial);

        const enemyGeometry = new THREE.TorusGeometry(ENEMY_RADIUS, 0.1, 16, 100);
        const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(freq, duration, type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // --- 4. Three.js åˆå§‹åŒ– (ä¿æŒä¸å˜) ---

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            scene.add(crosshair);
            scene.add(laserLine);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 5. æ•Œäººç”Ÿæˆä¸ç§»åŠ¨ (ä¿æŒä¸å˜) ---

        function spawnEnemy() {
            if (enemies.length >= MAX_ENEMIES) return;

            const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial.clone());
            
            const boundary = 10;
            const pos = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(boundary * 2), 
                THREE.MathUtils.randFloatSpread(boundary * 2), 
                -10
            );

            if (Math.random() < 0.5) { 
                pos.x = (Math.random() < 0.5 ? -1 : 1) * (boundary + 5);
            } else { 
                pos.y = (Math.random() < 0.5 ? -1 : 1) * (boundary + 5);
            }
            
            enemyMesh.position.copy(pos);

            const target = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(3), 
                THREE.MathUtils.randFloatSpread(3), 
                -5
            );
            
            const direction = target.clone().sub(enemyMesh.position).normalize();

            enemyMesh.userData = {
                direction: direction,
                isDead: false,
            };

            enemies.push(enemyMesh);
            scene.add(enemyMesh);
        }

        function updateEnemies(delta) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.userData.isDead) continue;

                enemy.position.addScaledVector(enemy.userData.direction, ENEMY_SPEED * delta * 60);

                enemy.rotation.x += 0.05;
                enemy.rotation.y += 0.05;

                if (enemy.position.z > camera.position.z - 2) {
                    enemy.userData.isDead = true;
                    showFloatText("MISS", new THREE.Vector3(enemy.position.x, enemy.position.y + 0.5, enemy.position.z), "#ff4500");
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                    playSound(100, 0.3, 'sawtooth'); 
                }
            }

            while (enemies.length < MAX_ENEMIES) {
                spawnEnemy();
            }
        }
        
        // --- 6. æ ¸å¿ƒæ¸¸æˆé€»è¾‘ï¼šç„å‡†ä¸å°„å‡» (ä¿æŒä¸å˜) ---

        function handleShooting(currentTime) {
            if (!isShooting || currentTime - lastShotTime < BULLET_COOLDOWN_MS) return;

            lastShotTime = currentTime;
            
            playSound(440, 0.1, 'square'); 

            let hitEnemy = null;
            let minDistance = Infinity;

            for (const enemy of enemies) {
                if (enemy.userData.isDead) continue;
                
                const enemyScreenPos = enemy.position.clone().project(camera);
                const enemyX = (enemyScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const enemyY = (-enemyScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                const crosshairScreenPos = crosshair.position.clone().project(camera);
                const crosshairX = (crosshairScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const crosshairY = (-crosshairScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                const dist = Math.sqrt(Math.pow(enemyX - crosshairX, 2) + Math.pow(enemyY - crosshairY, 2));

                if (dist < AIM_ASSIST_DISTANCE && dist < minDistance) {
                    minDistance = dist;
                    hitEnemy = enemy;
                }
            }

            if (hitEnemy) {
                hitEnemy.userData.isDead = true;
                scene.remove(hitEnemy);
                const index = enemies.indexOf(hitEnemy);
                if (index > -1) enemies.splice(index, 1);

                showFloatText("HIT!", new THREE.Vector3(hitEnemy.position.x, hitEnemy.position.y + 0.5, hitEnemy.position.z), "#00ff00");
                playSound(880, 0.1, 'sine'); 

                spawnEnemy();
            } else {
                showFloatText("MISS", crosshair.position.clone(), "#ff4500");
                playSound(150, 0.1, 'sawtooth');
            }
        }
        
        function showFloatText(text, worldPos, color) {
            const div = document.createElement('div');
            div.className = 'hit-effect';
            div.textContent = text;
            div.style.color = color;
            document.getElementById('game-container').appendChild(div);

            const screenPos = worldPos.project(camera);
            div.style.left = (screenPos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            div.style.top = (-screenPos.y * 0.5 + 0.5) * window.innerHeight + 'px';

            div.addEventListener('animationend', () => div.remove());
        }

        // --- 7. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
        
        function initMediaPipe() {
            // **MediaPipe æ¨¡å‹æ–‡ä»¶ä¼˜åŒ–: å°† unpkg æ›¿æ¢ä¸º jsdelivr**
            // MediaPipe æ¨¡å‹çš„ .js, .wasm, .data æ–‡ä»¶ä¼šé€šè¿‡è¿™ä¸ªå‡½æ•°åŠ è½½
            const BASE_URL = `https://registry.npmmirror.com/@mediapipe/hands/0.4.1646424915/files/`;

            hands = new Hands({
                locateFile: (file) => {
                    return `${BASE_URL}${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            isGameStarted = true;
                            loadingOverlay.style.display = 'none';
                            clock.start();
                            render();
                        };
                    })
                    .catch(err => {
                        console.error("æ— æ³•è·å–æ‘„åƒå¤´: ", err);
                        loadingOverlay.innerHTML = '<h1>âŒ æ— æ³•å¯åŠ¨æ‘„åƒå¤´</h1><p>è¯·æ£€æŸ¥æƒé™æˆ–è®¾å¤‡è¿æ¥ã€‚</p>';
                    });
            } else {
                loadingOverlay.innerHTML = '<h1>âŒ æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´</h1><p>è¯·ä½¿ç”¨æ”¯æŒ MediaDevices API çš„ç°ä»£æµè§ˆå™¨ã€‚</p>';
            }
        }

        function onResults(results) {
            const currentTime = performance.now();
            if (currentTime - lastDetectionTime < 1000 / 30) { 
                return;
            }
            lastDetectionTime = currentTime;

            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    const indexTip = landmarks[8]; 
                    const thumbTip = landmarks[4];  
                    const indexMCP = landmarks[5]; 
                    
                    const viewX = (1 - indexTip.x) * 2 - 1; 
                    const viewY = -(indexTip.y * 2 - 1); 
                    
                    const vector = new THREE.Vector3(viewX, viewY, 0.5); 
                    vector.unproject(camera);
                    
                    const direction = vector.sub(camera.position).normalize();
                    const distance = 3; 
                    crosshair.position.copy(camera.position).addScaledVector(direction, distance);
                    
                    const laserPoints = [camera.position, crosshair.position];
                    laserLine.geometry.setFromPoints(laserPoints);
                    
                    const isIndexStraight = indexTip.y < indexMCP.y;
                    
                    const thumbIndexDistance = Math.sqrt(
                        Math.pow(thumbTip.x - indexMCP.x, 2) + 
                        Math.pow(thumbTip.y - indexMCP.y, 2)
                    );
                    
                    const TRIGGER_THRESHOLD = 0.1; 
                    const isTriggerPulled = thumbIndexDistance < TRIGGER_THRESHOLD;
                    
                    if (isIndexStraight) {
                        if (isTriggerPulled && isReadyToShoot) {
                            isShooting = true;
                            isReadyToShoot = false; 
                            crosshair.material.color.set(0x00ff00); 
                        } else if (!isTriggerPulled) {
                            isReadyToShoot = true; 
                            isShooting = false;
                            crosshair.material.color.set(0xff0000); 
                        } else {
                            isShooting = false;
                        }
                    } else {
                        isShooting = false;
                        isReadyToShoot = true;
                        crosshair.material.color.set(0xffa500); 
                    }
                    
                } else {
                    isShooting = false;
                    crosshair.material.color.set(0x0000ff); 
                }
            } catch (e) {
                console.error("MediaPipe å¤„ç†é”™è¯¯: ", e);
            }
        }

        // --- 8. æ¸¸æˆä¸»å¾ªç¯ (ä¿æŒä¸å˜) ---

        async function detectHands() {
            if (!isGameStarted || videoElement.readyState < 2) {
                setTimeout(detectHands, 100);
                return;
            }
            await hands.send({ image: videoElement });
            setTimeout(detectHands, 1); 
        }

        function render() {
            requestAnimationFrame(render);
            
            if (!isGameStarted) return;

            const delta = clock.getDelta();
            const currentTime = clock.elapsedTime * 1000; 

            updateEnemies(delta);
            handleShooting(currentTime);

            renderer.render(scene, camera);
        }

        // --- 9. ä¸»å‡½æ•° (ä¿æŒä¸å˜) ---

        function main() {
            videoElement = document.getElementById('webcam');
            loadingOverlay = document.getElementById('loading-overlay');
            clock = new THREE.Clock(false); 

            initThree();
            initMediaPipe();
            
            detectHands();
        }

        window.onload = main;
    </script>
</body>
</html>
