<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR æ‰‹åŠ¿å°„å‡»æ¸¸æˆ V1.1</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        
        /* Loading é®ç½©æ ·å¼ - æ–°å¢è¿›åº¦æ¡ */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); color: #fff; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; font-family: sans-serif;
            text-align: center;
        }
        #progress-bar-container {
            width: 80%; max-width: 400px; height: 20px; background: #333;
            border-radius: 10px; margin: 15px 0; overflow: hidden;
        }
        #progress-bar {
            height: 100%; width: 0; background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.1s;
        }
        #status-text { margin-top: 5px; font-size: 0.9em; color: #ccc; }
        
        /* æ—§çš„åŠ è½½å™¨åŠ¨ç”» (ä¿ç•™) */
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite;
            margin-top: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ (ä¿ç•™) */
        .hit-effect {
            position: absolute; color: #ff0; font-weight: bold; font-size: 24px;
            pointer-events: none; opacity: 1; transform: translate(-50%, -50%);
            animation: float-up 0.8s ease-out forwards; z-index: 50;
        }
        @keyframes float-up {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100px) scale(0.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <h1>ğŸ”« æ­£åœ¨åŠ è½½ AR å°„å‡»èµ„æº...</h1>
        <p>æ­£åœ¨ä»å›½å†…é•œåƒæºåŠ è½½æ¨¡å‹æ–‡ä»¶...</p>
        <div id="progress-bar-container">
            <div id="progress-bar"></div>
        </div>
        <div id="status-text">åˆå§‹åŒ–ä¸­...</div>
    </div>

    <div id="game-container">
        <video id="webcam" autoplay playsinline style="display: none;"></video>
    </div>

    <script type="module">
        // --- 1. å¯¼å…¥ Three.js å’Œ MediaPipe ---
        
        // **Three.js ä¼˜åŒ–: æ”¹ç”¨ Cloudflare CDN (é€šå¸¸æ›´å¿«)**
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.module.min.js';
        
        // **MediaPipe ä¼˜åŒ–: ä¿æŒç‰ˆæœ¬é”å®šï¼Œæ”¹ç”¨ jsdelivr å®˜æ–¹å‘å¸ƒé“¾æ¥**
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js';
        
        // --- 2. å¸¸é‡ä¸æ¸¸æˆé…ç½® ---
        
        const MAX_ENEMIES = 4;
        const AIM_ASSIST_DISTANCE = 3; 
        const BULLET_COOLDOWN_MS = 300; 
        
        // **åª’ä½“æ–‡ä»¶åŸºå‡†è·¯å¾„ - ä½¿ç”¨å›½å†…é•œåƒ**
        const MEDIAPIPE_BASE_URL = `https://registry.npmmirror.com/@mediapipe/hands/0.4.1646424915/files/`;
        // éœ€è¦åŠ è½½çš„æ¨¡å‹æ–‡ä»¶åˆ—è¡¨åŠå…¶å¤§å° (ç”¨äºè®¡ç®—æ€»è¿›åº¦)
        // ä¼°ç®—æ–‡ä»¶å¤§å°ï¼Œä¸ç²¾ç¡®ä½†èƒ½æä¾›è¿›åº¦æ„Ÿ
        const MODEL_FILES = [
            { name: 'hands_solution_simd_wasm.wasm', size: 10 * 1024 * 1024 }, // çº¦ 10MB
            { name: 'hands_solution_simd_opt.data', size: 1 * 1024 * 1024 }, // çº¦ 1MB
        ];
        const TOTAL_MODEL_SIZE = MODEL_FILES.reduce((sum, file) => sum + file.size, 0);

        // --- 3. æ¸¸æˆçŠ¶æ€ä¸æ ¸å¿ƒå¯¹è±¡ (ç•¥) ---

        let videoElement, loadingOverlay, progressBar, statusText;
        let scene, camera, renderer, clock;
        let hands, lastDetectionTime = 0;
        let enemies = [];
        let lastShotTime = 0;
        let isShooting = false;
        let isReadyToShoot = true; 
        let isGameStarted = false;
        
        // ... (çœç•¥æ‰€æœ‰ THREE.js Mesh å’Œ AudioContext å®šä¹‰ï¼Œå®ƒä»¬ä¿æŒä¸å˜) ...
        const crosshairGeometry = new THREE.SphereGeometry(0.05);
        const crosshairMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const crosshair = new THREE.Mesh(crosshairGeometry, crosshairMaterial);
        
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -10)]);
        const laserMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const laserLine = new THREE.Line(laserGeometry, laserMaterial);

        const enemyGeometry = new THREE.TorusGeometry(0.5, 0.1, 16, 100);
        const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(freq, duration, type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        // ... (çœç•¥ initThree, spawnEnemy, updateEnemies, handleShooting, showFloatText ç­‰å‡½æ•°ï¼Œå®ƒä»¬ä¿æŒä¸å˜) ...
        // ä¸ºäº†ç®€æ´ï¼Œè¿™é‡Œåªä¿ç•™ MediaPipe ç›¸å…³çš„æ ¸å¿ƒæ”¹åŠ¨ã€‚

        // --- æ ¸å¿ƒï¼šå¸¦è¿›åº¦æ¡çš„æ¨¡å‹ä¸‹è½½å‡½æ•° ---
        
        let bytesDownloaded = 0;
        
        function updateProgress(bytes) {
            bytesDownloaded += bytes;
            const percentage = Math.min(100, (bytesDownloaded / TOTAL_MODEL_SIZE) * 100);
            progressBar.style.width = `${percentage}%`;
        }

        /**
         * ä½¿ç”¨ Fetch API æ‰‹åŠ¨ä¸‹è½½æ–‡ä»¶å¹¶æ˜¾ç¤ºè¿›åº¦
         * @param {string} url - æ–‡ä»¶ URL
         * @returns {Promise<Response>} 
         */
        async function fetchWithProgress(url) {
            statusText.textContent = `æ­£åœ¨ä¸‹è½½: ${url.split('/').pop()}...`;
            
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`ä¸‹è½½å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.status}`);
            }

            // MediaPipe æœŸæœ›è¿”å›ä¸€ä¸ªå¸¦æœ‰ ArrayBuffer çš„ Response å¯¹è±¡
            const contentType = response.headers.get('content-type');
            
            // å¦‚æœæ–‡ä»¶æ˜¯æ–‡æœ¬ç±»å‹ï¼Œç›´æ¥è¿”å› text()
            if (contentType && contentType.includes('text/javascript')) {
                 return response;
            }

            // å¯¹äºäºŒè¿›åˆ¶æ–‡ä»¶ (WASM/DATA)ï¼Œä½¿ç”¨ ReadableStream è¯»å–è¿›åº¦
            const reader = response.body.getReader();
            const chunks = [];
            
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                chunks.push(value);
                updateProgress(value.length);
            }

            const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
            const buffer = new Uint8Array(totalLength);
            let offset = 0;
            for (const chunk of chunks) {
                buffer.set(chunk, offset);
                offset += chunk.length;
            }

            // åˆ›å»ºä¸€ä¸ªæ–°çš„ Response å¯¹è±¡ï¼Œæ¨¡æ‹Ÿ MediaPipe æ‰€éœ€çš„æ ¼å¼
            return new Response(buffer.buffer, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers,
            });
        }


        // --- 7. MediaPipe åˆå§‹åŒ– (æ›¿æ¢åŠ è½½é€»è¾‘) ---
        
        function initMediaPipe() {
            progressBar = document.getElementById('progress-bar');
            statusText = document.getElementById('status-text');

            hands = new Hands({
                // 1. hands.js è„šæœ¬æœ¬èº«ä½¿ç”¨ jsdelivr (å·²åœ¨ import å¤„å®šä¹‰)

                // 2. å†…éƒ¨æ¨¡å‹æ–‡ä»¶ä½¿ç”¨å›½å†…é•œåƒ + è¿›åº¦æ¡åŠ è½½
                locateFile: (file) => {
                    return `${MEDIAPIPE_BASE_URL}${file}`;
                },
                // å¼ºåˆ¶ MediaPipe ä½¿ç”¨æˆ‘ä»¬çš„è‡ªå®šä¹‰ fetch å‡½æ•°
                moduleConfig: {
                    fetchResource: fetchWithProgress 
                }
            });
            
            // å½“æ‰€æœ‰æ¨¡å‹åŠ è½½å’Œåˆå§‹åŒ–å®Œæ¯•åè§¦å‘çš„äº‹ä»¶
            hands.initialize().then(() => {
                statusText.textContent = "æ¨¡å‹åŠ è½½å®Œæˆï¼Œæ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...";
                
                // å°è¯•æ‰“å¼€æ‘„åƒå¤´
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia({ video: true })
                        .then(stream => {
                            videoElement.srcObject = stream;
                            videoElement.onloadedmetadata = () => {
                                videoElement.play();
                                isGameStarted = true;
                                loadingOverlay.style.display = 'none';
                                clock.start();
                                render();
                            };
                        })
                        .catch(err => {
                            console.error("æ— æ³•è·å–æ‘„åƒå¤´: ", err);
                            loadingOverlay.innerHTML = '<h1>âŒ æ— æ³•å¯åŠ¨æ‘„åƒå¤´</h1><p>è¯·æ£€æŸ¥æƒé™æˆ–è®¾å¤‡è¿æ¥ã€‚</p>';
                        });
                } else {
                    loadingOverlay.innerHTML = '<h1>âŒ æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´</h1><p>è¯·ä½¿ç”¨æ”¯æŒ MediaDevices API çš„ç°ä»£æµè§ˆå™¨ã€‚</p>';
                }
            }).catch(e => {
                console.error("MediaPipe åˆå§‹åŒ–å¤±è´¥:", e);
                loadingOverlay.innerHTML = `<h1>âŒ æ¨¡å‹åŠ è½½å¤±è´¥</h1><p>è¯·æ£€æŸ¥ç½‘ç»œæˆ–é•œåƒæºæ˜¯å¦æœ‰æ•ˆã€‚é”™è¯¯: ${e.message}</p>`;
            });


            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
        }
        
        // ... (onResults, detectHands, render ç­‰å‡½æ•°ä¿æŒä¸å˜) ...


        // å®Œæ•´çš„å‡½æ•°å®šä¹‰ (ä¸ºäº†ç®€æ´ï¼Œè¿™é‡Œå°†æœªæ”¹åŠ¨çš„å‡½æ•°æ”¾åœ¨æœ«å°¾ï¼Œè¯·æ‚¨ç¡®ä¿æ›¿æ¢æ—¶è¦†ç›–æ‰€æœ‰å†…å®¹)
        
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);
            scene.add(crosshair);
            scene.add(laserLine);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function spawnEnemy() {
            if (enemies.length >= MAX_ENEMIES) return;
            const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial.clone());
            const boundary = 10;
            const pos = new THREE.Vector3(THREE.MathUtils.randFloatSpread(boundary * 2), THREE.MathUtils.randFloatSpread(boundary * 2), -10);
            if (Math.random() < 0.5) { pos.x = (Math.random() < 0.5 ? -1 : 1) * (boundary + 5); } else { pos.y = (Math.random() < 0.5 ? -1 : 1) * (boundary + 5); }
            enemyMesh.position.copy(pos);
            const target = new THREE.Vector3(THREE.MathUtils.randFloatSpread(3), THREE.MathUtils.randFloatSpread(3), -5);
            const direction = target.clone().sub(enemyMesh.position).normalize();
            enemyMesh.userData = { direction: direction, isDead: false, };
            enemies.push(enemyMesh);
            scene.add(enemyMesh);
        }

        function updateEnemies(delta) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.userData.isDead) continue;
                enemy.position.addScaledVector(enemy.userData.direction, 0.005 * delta * 60);
                enemy.rotation.x += 0.05;
                enemy.rotation.y += 0.05;
                if (enemy.position.z > camera.position.z - 2) {
                    enemy.userData.isDead = true;
                    showFloatText("MISS", new THREE.Vector3(enemy.position.x, enemy.position.y + 0.5, enemy.position.z), "#ff4500");
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                    playSound(100, 0.3, 'sawtooth'); 
                }
            }
            while (enemies.length < MAX_ENEMIES) {
                spawnEnemy();
            }
        }
        
        function handleShooting(currentTime) {
            if (!isShooting || currentTime - lastShotTime < BULLET_COOLDOWN_MS) return;
            lastShotTime = currentTime;
            playSound(440, 0.1, 'square'); 
            let hitEnemy = null;
            let minDistance = Infinity;
            for (const enemy of enemies) {
                if (enemy.userData.isDead) continue;
                const enemyScreenPos = enemy.position.clone().project(camera);
                const enemyX = (enemyScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const enemyY = (-enemyScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                const crosshairScreenPos = crosshair.position.clone().project(camera);
                const crosshairX = (crosshairScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const crosshairY = (-crosshairScreenPos.y * 0.5 + 0.5) * window.innerHeight;
                const dist = Math.sqrt(Math.pow(enemyX - crosshairX, 2) + Math.pow(enemyY - crosshairY, 2));
                if (dist < AIM_ASSIST_DISTANCE && dist < minDistance) {
                    minDistance = dist;
                    hitEnemy = enemy;
                }
            }
            if (hitEnemy) {
                hitEnemy.userData.isDead = true;
                scene.remove(hitEnemy);
                const index = enemies.indexOf(hitEnemy);
                if (index > -1) enemies.splice(index, 1);
                showFloatText("HIT!", new THREE.Vector3(hitEnemy.position.x, hitEnemy.position.y + 0.5, hitEnemy.position.z), "#00ff00");
                playSound(880, 0.1, 'sine'); 
                spawnEnemy();
            } else {
                showFloatText("MISS", crosshair.position.clone(), "#ff4500");
                playSound(150, 0.1, 'sawtooth');
            }
        }
        
        function showFloatText(text, worldPos, color) {
            const div = document.createElement('div');
            div.className = 'hit-effect';
            div.textContent = text;
            div.style.color = color;
            document.getElementById('game-container').appendChild(div);
            const screenPos = worldPos.project(camera);
            div.style.left = (screenPos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            div.style.top = (-screenPos.y * 0.5 + 0.5) * window.innerHeight + 'px';
            div.addEventListener('animationend', () => div.remove());
        }

        function onResults(results) {
            const currentTime = performance.now();
            if (currentTime - lastDetectionTime < 1000 / 30) { return; }
            lastDetectionTime = currentTime;
            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const indexTip = landmarks[8]; 
                    const thumbTip = landmarks[4];  
                    const indexMCP = landmarks[5]; 
                    const viewX = (1 - indexTip.x) * 2 - 1; 
                    const viewY = -(indexTip.y * 2 - 1); 
                    const vector = new THREE.Vector3(viewX, viewY, 0.5); 
                    vector.unproject(camera);
                    const direction = vector.sub(camera.position).normalize();
                    const distance = 3; 
                    crosshair.position.copy(camera.position).addScaledVector(direction, distance);
                    const laserPoints = [camera.position, crosshair.position];
                    laserLine.geometry.setFromPoints(laserPoints);
                    const isIndexStraight = indexTip.y < indexMCP.y;
                    const thumbIndexDistance = Math.sqrt(
                        Math.pow(thumbTip.x - indexMCP.x, 2) + 
                        Math.pow(thumbTip.y - indexMCP.y, 2)
                    );
                    const TRIGGER_THRESHOLD = 0.1; 
                    const isTriggerPulled = thumbIndexDistance < TRIGGER_THRESHOLD;
                    if (isIndexStraight) {
                        if (isTriggerPulled && isReadyToShoot) {
                            isShooting = true;
                            isReadyToShoot = false; 
                            crosshair.material.color.set(0x00ff00); 
                        } else if (!isTriggerPulled) {
                            isReadyToShoot = true; 
                            isShooting = false;
                            crosshair.material.color.set(0xff0000); 
                        } else {
                            isShooting = false;
                        }
                    } else {
                        isShooting = false;
                        isReadyToShoot = true;
                        crosshair.material.color.set(0xffa500); 
                    }
                } else {
                    isShooting = false;
                    crosshair.material.color.set(0x0000ff); 
                }
            } catch (e) {
                console.error("MediaPipe å¤„ç†é”™è¯¯: ", e);
            }
        }
        
        async function detectHands() {
            if (!isGameStarted || videoElement.readyState < 2) {
                setTimeout(detectHands, 100);
                return;
            }
            await hands.send({ image: videoElement });
            setTimeout(detectHands, 1); 
        }

        function render() {
            requestAnimationFrame(render);
            if (!isGameStarted) return;
            const delta = clock.getDelta();
            const currentTime = clock.elapsedTime * 1000; 
            updateEnemies(delta);
            handleShooting(currentTime);
            renderer.render(scene, camera);
        }

        function main() {
            videoElement = document.getElementById('webcam');
            loadingOverlay = document.getElementById('loading-overlay');
            progressBar = document.getElementById('progress-bar');
            statusText = document.getElementById('status-text');
            clock = new THREE.Clock(false); 
            initThree();
            initMediaPipe();
            detectHands();
        }

        window.onload = main;
    </script>
</body>
</html>
