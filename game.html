<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR æ‰‹åŠ¿å°„å‡»æ¸¸æˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        /* æ¸¸æˆç”»å¸ƒ */
        #game-container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        
        /* Loading é®ç½© */
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); color: #fff; z-index: 100;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; font-family: sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3; border-top: 4px solid #3498db;
            border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite;
            margin-top: 15px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ */
        .hit-effect {
            position: absolute; color: #ff0; font-weight: bold; font-size: 24px;
            pointer-events: none; opacity: 1; transform: translate(-50%, -50%);
            animation: float-up 0.8s ease-out forwards; z-index: 50;
        }
        @keyframes float-up {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -100px) scale(0.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <h1>ğŸ”« æ­£åœ¨åŠ è½½ AR å°„å‡»èµ„æº...</h1>
        <p>è¯·ç¡®ä¿æ‘„åƒå¤´å¯ç”¨ï¼Œæ­£åœ¨ä¸‹è½½ Three.js å’Œ MediaPipe æ¨¡å‹ã€‚</p>
        <div class="loader"></div>
    </div>

    <div id="game-container">
        <video id="webcam" autoplay playsinline style="display: none;"></video>
        </div>

    <script type="module">
        // --- 1. å¯¼å…¥ Three.js å’Œ MediaPipe ---
        
        // **å¼ºåˆ¶ç‰ˆæœ¬é”å®šä¸ unpkg æº**
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { Hands } from 'https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js';
        
        // --- 2. å¸¸é‡ä¸æ¸¸æˆé…ç½® ---
        
        const MAX_ENEMIES = 4;
        const ENEMY_RADIUS = 0.5;
        const AIM_ASSIST_DISTANCE = 3; // ç£å¸è¾…åŠ©ç„å‡†çš„å±å¹•åƒç´ è·ç¦»é˜ˆå€¼
        const BULLET_COOLDOWN_MS = 300; // å°„å‡»å†·å´æ—¶é—´
        const ENEMY_SPEED = 0.005;
        const FRAME_RATE = 60;
        
        // --- 3. æ¸¸æˆçŠ¶æ€ä¸æ ¸å¿ƒå¯¹è±¡ ---

        let videoElement, loadingOverlay;
        let scene, camera, renderer, clock;
        let hands, lastDetectionTime = 0;
        let enemies = [];
        let lastShotTime = 0;
        let isShooting = false;
        let isReadyToShoot = true; // æ‹‡æŒ‡çŠ¶æ€æ˜¯å¦å¯ä»¥è§¦å‘å°„å‡»
        let isGameStarted = false;

        // å‡†å¿ƒ (ä¸€ä¸ªç‚¹)
        const crosshairGeometry = new THREE.SphereGeometry(0.05);
        const crosshairMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const crosshair = new THREE.Mesh(crosshairGeometry, crosshairMaterial);
        
        // æ¿€å…‰æŒ‡ç¤ºçº¿
        const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -10)]);
        const laserMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const laserLine = new THREE.Line(laserGeometry, laserMaterial);

        // é£ç›˜ (æ•Œäºº)
        const enemyGeometry = new THREE.TorusGeometry(ENEMY_RADIUS, 0.1, 16, 100);
        const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

        // éŸ³æ•ˆ (ç®€å•çš„ Web Audio API æç¤ºéŸ³)
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(freq, duration, type) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            gainNode.gain.setValueAtTime(1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start();
            oscillator.stop(audioContext.currentTime + duration);
        }

        // --- 4. Three.js åˆå§‹åŒ– ---

        function initThree() {
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // é»‘è‰²èƒŒæ™¯ï¼Œæ¨¡æ‹Ÿ AR å åŠ 
            
            // æ‘„åƒå¤´ (ä½¿ç”¨ PerspectiveCamera æ¨¡æ‹Ÿ 3D æ·±åº¦)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // æ·»åŠ å‡†å¿ƒå’Œæ¿€å…‰
            scene.add(crosshair);
            scene.add(laserLine);

            // è°ƒæ•´çª—å£å¤§å°
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 5. æ•Œäººç”Ÿæˆä¸ç§»åŠ¨ ---

        function spawnEnemy() {
            if (enemies.length >= MAX_ENEMIES) return;

            const enemyMesh = new THREE.Mesh(enemyGeometry, enemyMaterial.clone());
            
            // éšæœºç”Ÿæˆåœ¨å±å¹•è¾¹ç¼˜
            const boundary = 10;
            const pos = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(boundary * 2), 
                THREE.MathUtils.randFloatSpread(boundary * 2), 
                -10
            );

            // ç¡®ä¿ç”Ÿæˆåœ¨è§†é‡ä¹‹å¤–ä½†é¢å‘ä¸­å¿ƒ (z=-5 æ˜¯ä¸­å¿ƒç‚¹)
            if (Math.random() < 0.5) { // å·¦å³
                pos.x = (Math.random() < 0.5 ? -1 : 1) * (boundary + 5);
            } else { // ä¸Šä¸‹
                pos.y = (Math.random() < 0.5 ? -1 : 1) * (boundary + 5);
            }
            
            enemyMesh.position.copy(pos);

            // ç›®æ ‡ç‚¹ (å±å¹•ä¸­å¿ƒé™„è¿‘)
            const target = new THREE.Vector3(
                THREE.MathUtils.randFloatSpread(3), 
                THREE.MathUtils.randFloatSpread(3), 
                -5
            );
            
            // ç§»åŠ¨æ–¹å‘
            const direction = target.clone().sub(enemyMesh.position).normalize();

            // å­˜å‚¨æ•Œäººæ•°æ®
            enemyMesh.userData = {
                direction: direction,
                isDead: false,
            };

            enemies.push(enemyMesh);
            scene.add(enemyMesh);
        }

        function updateEnemies(delta) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (enemy.userData.isDead) continue;

                // ç§»åŠ¨
                enemy.position.addScaledVector(enemy.userData.direction, ENEMY_SPEED * delta * 60);

                // æ—‹è½¬
                enemy.rotation.x += 0.05;
                enemy.rotation.y += 0.05;

                // æ£€æŸ¥æ˜¯å¦é£è¿‡ä¸­å¿ƒç‚¹ (z > camera.position.z - 2)
                if (enemy.position.z > camera.position.z - 2) {
                    // MISS
                    enemy.userData.isDead = true;
                    showFloatText("MISS", new THREE.Vector3(enemy.position.x, enemy.position.y + 0.5, enemy.position.z), "#ff4500");
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                    playSound(100, 0.3, 'sawtooth'); // MISS éŸ³æ•ˆ
                }
            }

            // è¡¥ä½
            while (enemies.length < MAX_ENEMIES) {
                spawnEnemy();
            }
        }
        
        // --- 6. æ ¸å¿ƒæ¸¸æˆé€»è¾‘ï¼šç„å‡†ä¸å°„å‡» ---

        function handleShooting(currentTime) {
            if (!isShooting || currentTime - lastShotTime < BULLET_COOLDOWN_MS) return;

            lastShotTime = currentTime;
            
            playSound(440, 0.1, 'square'); // å°„å‡»éŸ³æ•ˆ

            // æ£€æŸ¥ç£å¸ç„å‡†æ˜¯å¦å‘½ä¸­
            let hitEnemy = null;
            let minDistance = Infinity;

            for (const enemy of enemies) {
                if (enemy.userData.isDead) continue;
                
                // 1. è·å–æ•Œäººå±å¹•åæ ‡
                const enemyScreenPos = enemy.position.clone().project(camera);
                const enemyX = (enemyScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const enemyY = (-enemyScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                // 2. å‡†å¿ƒå±å¹•åæ ‡ (MediaPipe å·²ç»åœ¨ (-1, 1) èŒƒå›´å†…ï¼Œç›¸å½“äºå±å¹•ä¸­å¿ƒ)
                const crosshairScreenPos = crosshair.position.clone().project(camera);
                const crosshairX = (crosshairScreenPos.x * 0.5 + 0.5) * window.innerWidth;
                const crosshairY = (-crosshairScreenPos.y * 0.5 + 0.5) * window.innerHeight;

                // 3. è®¡ç®—å±å¹•åƒç´ è·ç¦»
                const dist = Math.sqrt(Math.pow(enemyX - crosshairX, 2) + Math.pow(enemyY - crosshairY, 2));

                if (dist < AIM_ASSIST_DISTANCE && dist < minDistance) {
                    minDistance = dist;
                    hitEnemy = enemy;
                }
            }

            if (hitEnemy) {
                // HIT!
                hitEnemy.userData.isDead = true;
                scene.remove(hitEnemy);
                const index = enemies.indexOf(hitEnemy);
                if (index > -1) enemies.splice(index, 1);

                showFloatText("HIT!", new THREE.Vector3(hitEnemy.position.x, hitEnemy.position.y + 0.5, hitEnemy.position.z), "#00ff00");
                playSound(880, 0.1, 'sine'); // å‘½ä¸­éŸ³æ•ˆ

                // ç«‹å³è¡¥å……ä¸€ä¸ªæ•Œäºº
                spawnEnemy();
            } else {
                // MISS
                showFloatText("MISS", crosshair.position.clone(), "#ff4500");
                playSound(150, 0.1, 'sawtooth');
            }
        }
        
        // æµ®åŠ¨æ–‡å­—ç‰¹æ•ˆ
        function showFloatText(text, worldPos, color) {
            const div = document.createElement('div');
            div.className = 'hit-effect';
            div.textContent = text;
            div.style.color = color;
            document.getElementById('game-container').appendChild(div);

            // è½¬æ¢ä¸ºå±å¹•åæ ‡
            const screenPos = worldPos.project(camera);
            div.style.left = (screenPos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            div.style.top = (-screenPos.y * 0.5 + 0.5) * window.innerHeight + 'px';

            // åŠ¨ç”»ç»“æŸåç§»é™¤
            div.addEventListener('animationend', () => div.remove());
        }

        // --- 7. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
        
        function initMediaPipe() {
            // **å¼ºåˆ¶ä½¿ç”¨ unpkg æº**
            hands = new Hands({
                locateFile: (file) => {
                    return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            // å°è¯•æ‰“å¼€æ‘„åƒå¤´
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoElement.srcObject = stream;
                        videoElement.onloadedmetadata = () => {
                            videoElement.play();
                            isGameStarted = true;
                            loadingOverlay.style.display = 'none';
                            // å¯åŠ¨æ¸¸æˆå¾ªç¯
                            clock.start();
                            render();
                        };
                    })
                    .catch(err => {
                        console.error("æ— æ³•è·å–æ‘„åƒå¤´: ", err);
                        loadingOverlay.innerHTML = '<h1>âŒ æ— æ³•å¯åŠ¨æ‘„åƒå¤´</h1><p>è¯·æ£€æŸ¥æƒé™æˆ–è®¾å¤‡è¿æ¥ã€‚</p>';
                    });
            } else {
                loadingOverlay.innerHTML = '<h1>âŒ æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´</h1><p>è¯·ä½¿ç”¨æ”¯æŒ MediaDevices API çš„ç°ä»£æµè§ˆå™¨ã€‚</p>';
            }
        }

        function onResults(results) {
            // **æ€§èƒ½ï¼šé™åˆ¶ AI æ£€æµ‹é¢‘ç‡**
            const currentTime = performance.now();
            if (currentTime - lastDetectionTime < 1000 / 30) { // é™åˆ¶ä¸º 30 FPS æ£€æµ‹
                return;
            }
            lastDetectionTime = currentTime;

            // **é˜²å´©æºƒåŠ è½½ï¼štry-catch ä¿æŠ¤**
            try {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // A. è¯†åˆ«â€œæ‰‹æªâ€æ‰‹åŠ¿ (é£ŸæŒ‡ç„å‡†, æ‹‡æŒ‡æ‰£åŠ¨)
                    const indexTip = landmarks[8]; // é£ŸæŒ‡æŒ‡å°–
                    const thumbTip = landmarks[4];  // æ‹‡æŒ‡æŒ‡å°–
                    const indexMCP = landmarks[5]; // é£ŸæŒ‡æŒæŒ‡å…³èŠ‚
                    
                    // 1. å‡†å¿ƒä½ç½® (é£ŸæŒ‡æŒ‡å°– - 8å·ç‚¹)
                    // åæ ‡ä» MediaPipe çš„ (0-1) å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸º Three.js è§†å›¾åæ ‡
                    // å½’ä¸€åŒ–åæ ‡: (0,0) å·¦ä¸Šè§’, (1,1) å³ä¸‹è§’
                    // Three.js è§†å›¾åæ ‡: (-1, -1) å·¦ä¸‹è§’, (1, 1) å³ä¸Šè§’, æ·±åº¦ Z
                    
                    // X: 1 - indexTip.x (å·¦å³é•œåƒ) * 2 - 1 -> -1 (å³) åˆ° 1 (å·¦)
                    const viewX = (1 - indexTip.x) * 2 - 1; 
                    // Y: indexTip.y * 2 - 1 -> -1 (ä¸‹) åˆ° 1 (ä¸Š)
                    const viewY = -(indexTip.y * 2 - 1); // å±å¹•Yè½´ä¸Three.js Yè½´ç›¸å
                    
                    // å°† 2D å±å¹•ç‚¹è½¬æ¢ä¸º 3D ä¸–ç•Œåæ ‡ (åœ¨ z=-3 çš„å¹³é¢ä¸Š)
                    const vector = new THREE.Vector3(viewX, viewY, 0.5); // 0.5 æ˜¯ä¸€ä¸ªè¿‘å¹³é¢ç‚¹
                    vector.unproject(camera);
                    
                    // è®¾ç½®å‡†å¿ƒä½ç½®
                    const direction = vector.sub(camera.position).normalize();
                    const distance = 3; // å°†å‡†å¿ƒæ”¾åœ¨ä¸€ä¸ªå›ºå®šçš„è·ç¦»ä¸Š
                    crosshair.position.copy(camera.position).addScaledVector(direction, distance);
                    
                    // 2. æ¿€å…‰çº¿ (ä»æ‘„åƒæœºåˆ°å‡†å¿ƒ)
                    const laserPoints = [camera.position, crosshair.position];
                    laserLine.geometry.setFromPoints(laserPoints);
                    
                    // 3. å°„å‡»è¯†åˆ« (æ‹‡æŒ‡æ‰£åŠ¨åˆ¤æ–­)
                    // å°„å‡»åˆ¤æ–­ï¼šé£ŸæŒ‡æ¯”ç›´ (8å·ç‚¹ è¿œäº 5å·ç‚¹) ä¸” æ‹‡æŒ‡å°– (4å·ç‚¹) æ¥è¿‘ é£ŸæŒ‡æŒæŒ‡å…³èŠ‚ (5å·ç‚¹)
                    const isIndexStraight = indexTip.y < indexMCP.y;
                    
                    // è®¡ç®—æ‹‡æŒ‡å°–å’Œé£ŸæŒ‡æŒæŒ‡å…³èŠ‚çš„è·ç¦» (å½’ä¸€åŒ–è·ç¦»)
                    const thumbIndexDistance = Math.sqrt(
                        Math.pow(thumbTip.x - indexMCP.x, 2) + 
                        Math.pow(thumbTip.y - indexMCP.y, 2)
                    );
                    
                    const TRIGGER_THRESHOLD = 0.1; // è§¦å‘é˜ˆå€¼
                    const isTriggerPulled = thumbIndexDistance < TRIGGER_THRESHOLD;
                    
                    // çŠ¶æ€æœºï¼šåªæœ‰å½“ isIndexStraight æˆç«‹ï¼Œä¸”æ‹‡æŒ‡ä»â€œæœªæ‰£åŠ¨â€ -> â€œæ‰£åŠ¨â€æ‰è§¦å‘
                    if (isIndexStraight) {
                        if (isTriggerPulled && isReadyToShoot) {
                            isShooting = true;
                            isReadyToShoot = false; // è¿›å…¥å†·å´çŠ¶æ€
                            crosshair.material.color.set(0x00ff00); // æ‰£åŠ¨æ—¶å˜ç»¿
                        } else if (!isTriggerPulled) {
                            isReadyToShoot = true; // æ‹‡æŒ‡æŠ¬èµ·ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡å°„å‡»
                            isShooting = false;
                            crosshair.material.color.set(0xff0000); // ç„å‡†æ—¶å˜çº¢
                        } else {
                            isShooting = false;
                        }
                    } else {
                        // éæ‰‹æªæ‰‹åŠ¿
                        isShooting = false;
                        isReadyToShoot = true;
                        crosshair.material.color.set(0xffa500); // éç„å‡†å§¿æ€å˜æ©™
                    }
                    
                } else {
                    // æœªæ£€æµ‹åˆ°æ‰‹
                    isShooting = false;
                    crosshair.material.color.set(0x0000ff); // æœªæ£€æµ‹åˆ°æ‰‹å˜è“
                }
            } catch (e) {
                // **é˜²å´©æºƒåŠ è½½ï¼šæ‰‹åŠ¿è¯†åˆ«å¾ªç¯ try-catch ä¿æŠ¤**
                console.error("MediaPipe å¤„ç†é”™è¯¯: ", e);
            }
        }

        // --- 8. æ¸¸æˆä¸»å¾ªç¯ ---

        async function detectHands() {
            if (!isGameStarted || videoElement.readyState < 2) {
                setTimeout(detectHands, 100);
                return;
            }
            // å¾ªç¯æ£€æµ‹
            await hands.send({ image: videoElement });
            setTimeout(detectHands, 1); // å°½å¿«å†æ¬¡æ£€æµ‹
        }

        function render() {
            // **æ€§èƒ½ï¼šæ¸²æŸ“è·‘æ»¡ 60å¸§**
            requestAnimationFrame(render);
            
            if (!isGameStarted) return;

            const delta = clock.getDelta();
            const currentTime = clock.elapsedTime * 1000; // æ¯«ç§’

            updateEnemies(delta);
            handleShooting(currentTime);

            renderer.render(scene, camera);
        }

        // --- 9. ä¸»å‡½æ•° ---

        function main() {
            videoElement = document.getElementById('webcam');
            loadingOverlay = document.getElementById('loading-overlay');
            clock = new THREE.Clock(false); // åˆå§‹æš‚åœ

            initThree();
            initMediaPipe();
            
            // å¯åŠ¨ MediaPipe å¼‚æ­¥å¾ªç¯
            detectHands();
        }

        window.onload = main;
    </script>
</body>
</html>